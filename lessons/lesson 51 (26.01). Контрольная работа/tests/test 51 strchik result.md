Вопросы с выбором варианта: 22/100%  
# Вопрос 1. Тема 1: Условные конструкции и циклы в Python
  
Какие значения в Python считаются ложными (falsy)?
  
Варианты ответов:
1) ❌ Только None
2) Только пустые строки
3) Значения, приводимые к False
4) Только значение 0
5) Только отрицательные числа
  
### ИИ анализ
Вы выбрали неверный вариант. В Python ложными (falsy) считаются не только `None`, а целая категория значений, которые приводятся к `False` в булевом контексте. К ним относятся, например, `False`, `None`, нулевые числовые значения, пустые коллекции (список, строка, кортеж, словарь). Правильный ответ — "Значения, приводимые к False", так как это наиболее точное и полное определение.  

# Вопрос 2. Тема 1: Условные конструкции и циклы в Python
  
Зачем используется `elif`?
  
Варианты ответов:
1) ❌ Для остановки цикла
2) Для обработки исключений
3) Для вывода текста
4) Для добавления нового условия
5) Для создания функции
  
### ИИ анализ
Вы выбрали неверный вариант. Ключевое слово `elif` не используется для остановки циклов; для этого существует `break`. `elif` (сокращение от "else if") предназначено для добавления альтернативных условий в цепочку `if-else`. Оно позволяет проверить несколько последовательных условий, выполняя код только первого из них, которое окажется истинным.  

# Вопрос 3. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `for`?
  
Варианты ответов:
1) ❌ Когда нужно ждать событие
2) Когда известен набор значений
3) Когда нет итератора
4) Когда нужно повторять бесконечно
5) Когда условие меняется случайно
  
### ИИ анализ
Вы выбрали неверный вариант. Цикл `for` не предназначен для ожидания событий; для этого используются другие механизмы. Цикл `for` идеально подходит для итерации по известной последовательности или итерируемому объекту (списку, строке, диапазону `range`, ключам словаря). Его используют, когда количество итераций известно заранее или определяется набором значений.  

# Вопрос 4. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `while`?
  
Варианты ответов:
1) ❌ Когда есть range
2) Когда условие важно каждый раз
3) Когда есть список значений
4) Когда нужен словарь
5) Когда нужна сортировка
  
### ИИ анализ
Вы выбрали неверный вариант. Наличие `range` — это типичный случай для цикла `for`. Цикл `while` используется, когда повторение зависит от условия, которое проверяется перед каждой итерацией. Он удобен, когда количество итераций неизвестно заранее и цикл должен выполняться, пока условие истинно (например, чтение данных до определённого символа).  

# Вопрос 5. Тема 1: Условные конструкции и циклы в Python
  
Что делает `break`?
  
Варианты ответов:
1) ❌ Пропускает итерацию
2) Переходит в else блока
3) Останавливает программу
4) Перезапускает цикл
5) Полностью прерывает цикл
  
### ИИ анализ
Вы выбрали неверный вариант. Оператор `break` не пропускает итерацию; для этого используется `continue`. `break` предназначен для немедленного и полного прерывания выполнения цикла (`for` или `while`). Управление передаётся следующей за циклом инструкции, а блок `else` цикла (если он есть) при этом не выполняется.  

# Вопрос 6. Тема 1: Условные конструкции и циклы в Python
  
Что делает `continue`?
  
Варианты ответов:
1) ❌ Переходит к else блока
2) Возвращает значение
3) Пропускает текущую итерацию
4) Завершает цикл полностью
5) Завершает программу
  
### ИИ анализ
Вы выбрали неверный вариант. Оператор `continue` не переходит в блок `else` и не завершает цикл. Он используется внутри цикла для пропуска оставшейся части тела текущей итерации и немедленного перехода к проверке условия (в `while`) или к следующему элементу (в `for`). Цикл при этом продолжает работу.  

# Вопрос 7. Тема 1: Условные конструкции и циклы в Python
  
Когда выполняется `else` в конструкции `for ... else`?
  
Варианты ответов:
1) ❌ Только при ошибке
2) Всегда после первого шага
3) Только если был `continue`
4) Если цикл завершился без `break`
5) Только если цикл пустой
  
### ИИ анализ
Вы выбрали неверный вариант. Блок `else` в конструкции `for ... else` не связан с обработкой ошибок. Он выполняется только в том случае, если цикл завершился естественным образом, то есть не был прерван оператором `break`. Это полезно для поиска элементов: код в `else` выполняется, если искомый элемент не был найден.  

# Вопрос 8. Тема 1: Условные конструкции и циклы в Python
  
Как записать тернарное выражение (условие в одну строку) в Python?
  
Варианты ответов:
1) ✅ `b if a else c`
2) `a ? b : c`
3) `if a: b else: c`
4) `b unless a else c`
5) `if (a) {b} else {c}`
  
### ИИ анализ
Вы выбрали правильный вариант. Синтаксис тернарного условного оператора в Python — `<значение_if_true> if <условие> else <значение_if_false>`. Он позволяет компактно записать простое условие выбора значения. Другие варианты используют синтаксис, характерный для языков C или Ruby, который в Python не работает.  

# Вопрос 9. Тема 1: Условные конструкции и циклы в Python
  
Что такое итерация в цикле `for`?
  
Варианты ответов:
1) ❌ Объявление переменной
2) Создание списка
3) Запуск программы
4) Один проход тела цикла
5) Завершение цикла
  
### ИИ анализ
Вы выбрали неверный вариант. Итерация — это не объявление переменной, а фундаментальное понятие в циклах. В контексте цикла `for` одна итерация соответствует одному полному проходу тела цикла для текущего элемента из итерируемого объекта. Каждая итерация обрабатывает следующий элемент последовательности.  

# Вопрос 10. Тема 1: Условные конструкции и циклы в Python
  
Как остановить цикл `while True` изнутри цикла?
  
Варианты ответов:
1) ❌ Использовать `print`
2) Использовать `break`
3) Использовать `pass`
4) Использовать `continue`
5) Использовать `elif`
  
### ИИ анализ
Вы выбрали неверный вариант. Цикл `while True` является бесконечным, так как его условие всегда истинно. Единственный способ корректно остановить его изнутри — использовать оператор `break` при выполнении какого-либо внутреннего условия. `continue` лишь перейдёт к следующей итерации, а `pass` ничего не делает.  

# Вопрос 11. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.append(x)` от `list.extend(iterable)`?
  
Варианты ответов:
1) ❌ `extend` удаляет элементы
2) `append` добавляет один элемент
3) `append` добавляет все элементы
4) Разницы нет
5) `extend` добавляет один элемент
  
### ИИ анализ
Вы выбрали неверный вариант. Метод `extend` не удаляет элементы. Ключевое отличие: `append(x)` добавляет объект `x` как один новый элемент в конец списка (даже если `x` — это список, он станет вложенным). `extend(iterable)` добавляет все элементы из итерируемого объекта по отдельности, расширяя список.  

# Вопрос 12. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как обратиться к последнему элементу списка по индексу?
  
Варианты ответов:
1) ✅ `a[-1]`
2) `a[0]`
3) `a[last]`
4) `a[1]`
5) `a[end]`
  
### ИИ анализ
Вы выбрали правильный вариант. В Python поддерживается отрицательная индексация. Индекс `-1` ссылается на последний элемент, `-2` — на предпоследний и так далее. Это самый простой и питонический способ получить последний элемент, не зная длины списка. Синтаксисы `a[last]` или `a[end]` неверны.  

# Вопрос 13. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `start` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс конца среза
2) ❌ Тип результата
3) Количество элементов
4) Шаг среза
5) Индекс начала среза
  
### ИИ анализ
Вы выбрали неверный вариант. Параметр `start` в срезе не определяет тип результата. Он задаёт индекс элемента, с которого начинается срез (включительно). Если `start` не указан, срез начинается с начала последовательности. Это позволяет гибко выбирать подпоследовательности из списков, строк и кортежей.  

# Вопрос 14. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `stop` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) ✅ Индекс конца, не включая
2) Индекс начала
3) Шаг
4) Значение элемента
5) Размер списка
  
### ИИ анализ
Вы выбрали правильный вариант. Параметр `stop` определяет индекс, на котором срез заканчивается, причём элемент с этим индексом **не включается** в результат. Это соглашение "полуоткрытого интервала" (как в `range`) делает расчёты длины среза простыми: `stop - start`. Если `stop` не указан, срез идёт до конца последовательности.  

# Вопрос 15. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `step` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) ❌ Тип списка
2) Индекс начала
3) Шаг выборки элементов
4) Индекс конца
5) Длину списка
  
### ИИ анализ
Вы выбрали неверный вариант. Параметр `step` не определяет тип списка. Он задаёт шаг, с которым выбираются элементы из последовательности. Например, `step=2` берёт каждый второй элемент. Отрицательный `step` позволяет итерироваться в обратном порядке. Это мощный инструмент для реверсирования (`[::-1]`) или выборки данных с определённым интервалом.  

# Вопрос 16. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.copy()` от `list2 = list1`?
  
Варианты ответов:
1) ✅ `copy()` делает новый список
2) `=` делает глубокую копию
3) `copy()` связывает ссылки
4) Разницы нет
5) `=` копирует элементы
  
### ИИ анализ
Вы выбрали правильный вариант. Присваивание `list2 = list1` создаёт новую ссылку на тот же объект списка в памяти (поверхностное связывание). Изменения через одну переменную будут видны через другую. Метод `list.copy()` создаёт новый список-копию, содержащий те же элементы. Это неглубокая (shallow) копия: вложенные объекты по-прежнему разделяются.  

# Вопрос 17. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как правильно создать список списков без «общей» вложенной ссылки?
  
Варианты ответов:
1) ❌ `a = [[0] * 3] * 3`
2) `a = (0, 0, 0)`
3) `a = [0] * 9`
4) `a = [[0] * 3 for _ in range(3)]`
5) `a = {0: 3}`
  
### ИИ анализ
Вы выбрали неверный вариант. Конструкция `[[0] * 3] * 3` создаёт список, содержащий три ссылки на **один и тот же** внутренний список `[0, 0, 0]`. Изменение одного внутреннего списка затронет все. Правильный способ — использовать list comprehension: `[[0] * 3 for _ in range(3)]`. На каждой итерации создаётся новый независимый список.  

# Вопрос 18. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что такое list comprehension?
  
Варианты ответов:
1) ✅ Короткая запись создания списка
2) Вид цикла while
3) Тип словаря
4) Способ сортировки
5) Способ чтения файла
  
### ИИ анализ
Вы выбрали правильный вариант. List comprehension (генератор списка) — это компактный синтаксис для создания нового списка на основе итерируемого объекта, часто с применением фильтрации или преобразования. Он заменяет многострочный цикл `for` с `append` одной выразительной строкой, например: `[x*2 for x in range(5) if x > 0]`.  

# Вопрос 19. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается удаление по индексу и удаление по значению в списке?
  
Варианты ответов:
1) ❌ По значению удаляют индекс
2) Разницы нет
3) По индексу удаляют позицию
4) По значению удаляют диапазон
5) По индексу удаляют все совпадения
  
### ИИ анализ
Вы выбрали неверный вариант. Разница существенна. Метод `list.pop(index)` удаляет элемент по заданной позиции (индексу) и возвращает его. Метод `list.remove(value)` ищет **первое** вхождение указанного значения в списке и удаляет этот элемент. Если значения нет, возникает ошибка `ValueError`.  

# Вопрос 20. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `sort()` от `sorted()`?
  
Варианты ответов:
1) ❌ `sorted()` меняет список
2) Разницы нет
3) `sort()` меняет список на месте
4) `sorted()` работает только с set
5) `sort()` возвращает новый список
  
### ИИ анализ
Вы выбрали неверный вариант. Главное отличие: метод `list.sort()` сортирует список **на месте** (in-place), изменяя исходный список и возвращая `None`. Встроенная функция `sorted(iterable)` не изменяет исходную коллекцию, а возвращает **новый** отсортированный список. `sorted()` работает с любым итерируемым объектом (списки, кортежи, строки).  

# Вопрос 21. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `d.get(key)` от `d[key]`, если ключа нет?
  
Варианты ответов:
1) ✅ `get` вернёт None по умолчанию
2) Разницы нет
3) `[]` вернёт None по умолчанию
4) `get` всегда вызывает ошибку
5) `get` удалит ключ
  
### ИИ анализ
Вы выбрали правильный вариант. Обращение по ключу `d[key]` вызовет ошибку `KeyError`, если ключа нет в словаре. Метод `d.get(key)` в такой ситуации безопасно возвращает `None` (или другое значение, указанное вторым аргументом: `d.get(key, default)`). Это делает `get` предпочтительным, когда отсутствие ключа является ожидаемой ситуацией.  

# Вопрос 22. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Как добавить или обновить значение в словаре по ключу?
  
Варианты ответов:
1) ❌ `d.add(k, v)`
2) `d.push(k, v)`
3) `d[key] = value`
4) `d.insert(key)`
5) `d.append(value)`
  
### ИИ анализ
Вы выбрали неверный вариант. Методы `add`, `push`, `insert` и `append` не используются для работы со словарями. Основной способ добавления новой пары ключ-значение или обновления существующего значения — это оператор присваивания: `d[key] = value`. Если ключ существует, его значение будет перезаписано; если нет — пара будет добавлена.  

# Вопрос 23. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.keys()`?
  
Варианты ответов:
1) ❌ Список ключей
2) Количество ключей
3) Пару ключ-значение
4) Только первый ключ
5) Представление ключей (view)
  
### ИИ анализ
Вы выбрали неверный вариант. В современных версиях Python (3.x) `dict.keys()` возвращает не список, а специальный объект `dict_keys`, который является **динамическим представлением (view)** ключей словаря. Это представление отражает все изменения в словаре и поддерживает эффективные операции проверки принадлежности. Его можно легко преобразовать в список: `list(d.keys())`.  

# Вопрос 24. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.values()`?
  
Варианты ответов:
1) ❌ Ничего не возвращает
2) Список значений
3) Представление значений (view)
4) Копию словаря
5) Только уникальные значения
  
### ИИ анализ
Вы выбрали неверный вариант. Метод `dict.values()` возвращает объект `dict_values` — динамическое **представление значений** словаря. Как и `keys()`, это view, которое обновляется при изменении словаря. Оно не является списком, но его можно итерировать или преобразовать в список. Значения в представлении не гарантированно уникальны.  

# Вопрос 25. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.items()`?
  
Варианты ответов:
1) ❌ Только значения
2) Индексы элементов
3) Только ключи
4) Сумму элементов
5) Представление пар (key, value)
  
### ИИ анализ
Вы выбрали неверный вариант. Метод `dict.items()` возвращает объект `dict_items` — динамическое **представление пар "ключ-значение"** словаря в виде кортежей `(key, value)`. Это чрезвычайно полезно для итерации по словарю одновременно по ключам и значениям, например: `for k, v in d.items():`. Представление также обновляется вместе со словарём.  

# Вопрос 26. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Когда удобно использовать `defaultdict`?
  
Варианты ответов:
1) ❌ Для удаления ключей
2) Для сортировки словаря
3) Для чтения файла
4) Для значений по умолчанию
5) Для шифрования данных
  
### ИИ анализ
Вы выбрали неверный вариант. `defaultdict` из модуля `collections` не используется для удаления ключей. Его основное назначение — автоматическое предоставление **значения по умолчанию** для отсутствующих ключей при первом обращении. Это избавляет от необходимости проверять наличие ключа с помощью `if key in dict` или `dict.get()`, упрощая код, например, при группировке элементов.  

# Вопрос 27. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `set` от `frozenset`?
  
Варианты ответов:
1) ❌ `set` хранит пары
2) `frozenset` неизменяемый
3) `frozenset` поддерживает add
4) `set` всегда упорядочен
5) Разницы нет
  
### ИИ анализ
Вы выбрали неверный вариант. Основное и ключевое отличие: тип `frozenset` является **неизменяемым (immutable)**, в то время как обычный `set` — изменяемый. Это означает, что в `frozenset` нельзя добавлять (`add`), удалять элементы или изменять его после создания. Благодаря неизменяемости `frozenset` может быть элементом другого множества или ключом словаря.  

# Вопрос 28. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Какие операции множеств соответствуют: пересечение, объединение, разность?
  
Варианты ответов:
1) ❌ `+, -, *`
2) `and, or, not`
3) `<<, >>, ^`
4) `in, not in, is`
5) `&, |, -`
  
### ИИ анализ
Вы выбрали неверный вариант. Для работы с множествами в Python используются специальные операторы: **пересечение** — `&` (или метод `.intersection()`), **объединение** — `|` (или `.union()`), **разность** — `-` (или `.difference()`). Операторы `+` и `*` для множеств не определены, так как они неоднозначны в контексте уникальных элементов.  

# Вопрос 29. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит list comprehension с фильтром `if`?
  
Варианты ответов:
1) ❌ `{k: v for k, v in a}`
2) `{x for x in a if x > 0}`
3) `(x for x in a if x > 0)`
4) `for x in a: if x > 0`
5) `[x for x in a if x > 0]`
  
### ИИ анализ
Вы выбрали неверный вариант. Правильный синтаксис list comprehension с фильтром `if` использует квадратные скобки: `[выражение for элемент in итерируемый if условие]`. Ваш выбор (`{x for x in a if x > 0}`) — это пример **set comprehension** (генератора множества). Вариант с круглыми скобками создаёт генераторное выражение, а не список.
# Вопрос 30. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит dict comprehension?
  
Варианты ответов:
1) ❌ `dict(k: v for k, v in pairs)`
2) `[k: v for k, v in pairs]`
3) `(k: v for k, v in pairs)`
4) `{k: v for k, v in pairs}`
5) `{k, v for k, v in pairs}`
  
### ИИ анализ
Студент выбрал неверный вариант. Dict comprehension в Python использует фигурные скобки `{}` и синтаксис `ключ: значение`, как в обычном словаре, но внутри выражения генератора. Правильный ответ — вариант 4: `{k: v for k, v in pairs}`. Вариант 1 неверен, так как `dict()` используется для создания словаря из итерируемого объекта, но не является синтаксисом comprehension.

# Вопрос 31. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит set comprehension?
  
Варианты ответов:
1) ✅ `{x for x in a}`
2) `{k: v for k, v in a}`
3) `[x for x in a]`
4) `set[x for x in a]`
5) `(x for x in a)`
  
### ИИ анализ
Студент выбрал правильный ответ. Set comprehension, как и dict comprehension, использует фигурные скобки `{}`, но без двоеточия, так как создаёт множество уникальных элементов. Синтаксис `{x for x in a}` корректен. Вариант 2 — это синтаксис для dict comprehension, вариант 3 — для list comprehension, а вариант 5 создаёт генераторное выражение.

# Вопрос 32. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Чем отличается `if/else` внутри comprehension от фильтра `if` в конце?
  
Варианты ответов:
1) ❌ `if/else` удаляет элементы
2) Они делают одно и то же
3) `if/else` меняет значение
4) Фильтр `if` создаёт else
5) Фильтр `if` всегда медленней
  
### ИИ анализ
Студент выбрал неверный вариант. Ключевое отличие в том, что условное выражение `if/else` (используемое перед `for`) изменяет вычисляемое значение на основе условия, в то время как фильтр `if` (после `for`) решает, включать ли элемент в итоговую коллекцию. Правильный ответ — вариант 3: `if/else` меняет значение. Фильтр `if` только фильтрует, не изменяя значения.

# Вопрос 33. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Когда comprehension лучше заменить обычным циклом `for`?
  
Варианты ответов:
1) ❌ Когда есть словарь
2) Когда нужен `if`
3) Когда нужен `range`
4) Когда список маленький
5) Когда логика стала сложной
  
### ИИ анализ
Студент выбрал неверный вариант. Comprehension предназначены для простых, ясных преобразований и фильтраций. Их следует заменять обычным циклом `for`, когда логика построения коллекции становится сложной (например, содержит много условий, вложенные циклы или побочные эффекты), чтобы сохранить читаемость кода. Правильный ответ — вариант 5.

# Вопрос 34. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что такое позиционный аргумент при вызове функции?
  
Варианты ответов:
1) ❌ Аргумент из словаря
2) Аргумент только в списке
3) Аргумент с именем
4) Аргумент из файла
5) Аргумент по порядку параметров
  
### ИИ анализ
Студент выбрал неверный вариант. Позиционный аргумент — это аргумент, который передаётся функции в том порядке, в котором параметры были объявлены. Его значение связывается с соответствующим параметром по позиции, а не по имени. Правильный ответ — вариант 5: аргумент по порядку параметров.

# Вопрос 35. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что такое именованный аргумент при вызове функции?
  
Варианты ответов:
1) ❌ Аргумент только в списке
2) Аргумент вида `name=value`
3) Аргумент без значения
4) Аргумент с типом str
5) Аргумент с индексом
  
### ИИ анализ
Студент выбрал неверный вариант. Именованный (или ключевой) аргумент передаётся с явным указанием имени параметра в формате `имя=значение`. Это позволяет передавать аргументы не по порядку и часто используется для параметров со значениями по умолчанию. Правильный ответ — вариант 2.

# Вопрос 36. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Почему опасно использовать изменяемый объект (например, `[]`) как значение по умолчанию?
  
Варианты ответов:
1) ❌ Он запрещён в Python
2) Он сохраняется между вызовами
3) Он медленно создаётся
4) Он всегда пустой
5) Он ломает import
  
### ИИ анализ
Студент выбрал неверный вариант. Значение по умолчанию для параметра функции вычисляется один раз — в момент определения функции. Если это значение является изменяемым объектом (например, список), то один и тот же объект будет использоваться при всех последующих вызовах функции, что может привести к неожиданному накоплению данных. Правильный ответ — вариант 2.

# Вопрос 37. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Для чего используется `*args`?
  
Варианты ответов:
1) ❌ Для остановки цикла
2) Для набора позиционных аргументов
3) Для передачи словаря
4) Для возврата значения
5) Для создания класса
  
### ИИ анализ
Студент выбрал неверный вариант. Параметр `*args` в определении функции позволяет ей принимать произвольное количество позиционных аргументов. Внутри функции `args` становится кортежем, содержащим все переданные позиционные аргументы. Правильный ответ — вариант 2.

# Вопрос 38. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Для чего используется `**kwargs`?
  
Варианты ответов:
1) ❌ Для создания модуля
2) Для чтения файла
3) Для набора списков
4) Для форматирования строки
5) Для набора именованных аргументов
  
### ИИ анализ
Студент выбрал неверный вариант. Параметр `**kwargs` позволяет функции принимать произвольное количество именованных (ключевых) аргументов. Внутри функции `kwargs` становится словарём, где ключи — это имена аргументов (строки), а значения — соответствующие значения. Правильный ответ — вариант 5.

# Вопрос 39. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что означает `return` в функции?
  
Варианты ответов:
1) ❌ Импорт модуля
2) Объявление переменной
3) Возврат значения и выход
4) Повтор вызова
5) Печать результата
  
### ИИ анализ
Студент выбрал неверный вариант. Оператор `return` завершает выполнение функции и возвращает указанное значение (или `None`, если значение не указано) в точку вызова. Управление программой передаётся обратно туда, откуда была вызвана функция. Правильный ответ — вариант 3.

# Вопрос 40. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что возвращает функция, если в ней нет `return`?
  
Варианты ответов:
1) ✅ None
2) Пустую строку
3) False
4) Ошибку
5) 0
  
### ИИ анализ
Студент выбрал правильный ответ. В Python функция всегда возвращает значение. Если выполнение функции достигает конца её тела без встречи с оператором `return`, или если `return` вызван без аргумента, функция неявно возвращает специальное значение `None`. Это фундаментальное правило языка.

# Вопрос 41. Тема 7: Функции args, kwargs, область видимости
  
В каком порядке обычно пишут параметры, если используются `*args` и `**kwargs`?
  
Варианты ответов:
1) Сначала `*args`, потом обычные
2) ✅ Обычные, потом `*args`, потом `**kwargs`
3) `**kwargs`, потом `*args`
4) Только `*args`, без обычных
5) Порядок не важен
  
### ИИ анализ
Студент выбрал правильный ответ. Стандартный и обязательный порядок параметров в определении функции: сначала обычные позиционные параметры, затем параметры со значениями по умолчанию (которые также могут быть именованными), затем `*args` для сбора лишних позиционных аргументов, и наконец `**kwargs` для сбора лишних именованных аргументов.

# Вопрос 42. Тема 7: Функции args, kwargs, область видимости
  
Что произойдёт, если передать позиционный аргумент после именованного?
  
Варианты ответов:
1) Будет ошибка синтаксиса
2) ❌ Будет предупреждение
3) Позиционный станет ключевым
4) Код отработает нормально
5) Python это игнорирует
  
### ИИ анализ
Студент выбрал неверный вариант. При вызове функции все позиционные аргументы должны идти перед любыми именованными аргументами. Нарушение этого правила приводит к ошибке синтаксиса (`SyntaxError`). Правильный ответ — вариант 1.

# Вопрос 43. Тема 7: Функции args, kwargs, область видимости
  
Как передать `*args` и `**kwargs` в другую функцию?
  
Варианты ответов:
1) Использовать `f(&args, &kwargs)`
2) ❌ Использовать `f(*kwargs, **args)`
3) Использовать `f(*args, **kwargs)`
4) Передать как строки
5) Использовать `f(args, kwargs)`
  
### ИИ анализ
Студент выбрал неверный вариант. Для передачи собранных позиционных и именованных аргументов в другую функцию используется оператор распаковки: `*` для распаковки кортежа/списка в позиционные аргументы и `**` для распаковки словаря в именованные аргументы. Правильный синтаксис — `f(*args, **kwargs)`. Правильный ответ — вариант 3.

# Вопрос 44. Тема 7: Функции args, kwargs, область видимости
  
Что такое локальная область видимости?
  
Варианты ответов:
1) Переменные в классе всегда
2) ❌ Переменные в библиотеке
3) Переменные в файле
4) Переменные внутри функции
5) Переменные из модуля
  
### ИИ анализ
Студент выбрал неверный вариант. Локальная область видимости (local scope) — это область внутри тела функции. Переменные, определённые внутри функции (включая её параметры), являются локальными и доступны только внутри этой функции (если не объявлены `global` или `nonlocal`). Правильный ответ — вариант 4.

# Вопрос 45. Тема 7: Функции args, kwargs, область видимости
  
Что такое глобальная область видимости?
  
Варианты ответов:
1) Переменные внутри if
2) ❌ Переменные внутри списка
3) Переменные внутри цикла
4) Переменные внутри lambda
5) Переменные на уровне модуля
  
### ИИ анализ
Студент выбрал неверный вариант. Глобальная область видимости (global scope) — это область на уровне модуля (файла Python). Переменные, определённые на этом уровне (вне всех функций и классов), являются глобальными и доступны для чтения во всём модуле. Для их изменения внутри функции требуется ключевое слово `global`. Правильный ответ — вариант 5.

# Вопрос 46. Тема 7: Функции args, kwargs, область видимости
  
Что делает `global`?
  
Варианты ответов:
1) Разрешает менять глобальную
2) ❌ Копирует значение
3) Делает переменную локальной
4) Удаляет переменные
5) Создаёт новый модуль
  
### ИИ анализ
Студент выбрал неверный вариант. Ключевое слово `global` используется внутри функции для объявления того, что определённое имя ссылается на глобальную переменную (переменную уровня модуля). Это позволяет функции не только читать, но и изменять значение этой глобальной переменной, а не создавать новую локальную с тем же именем. Правильный ответ — вариант 1.

# Вопрос 47. Тема 7: Функции args, kwargs, область видимости
  
Что делает `nonlocal`?
  
Варианты ответов:
1) Берёт из внешней функции
2) ❌ Делает переменную константой
3) Создаёт новый параметр
4) Делает переменную глобальной
5) Удаляет переменную
  
### ИИ анализ
Студент выбрал неверный вариант. Ключевое слово `nonlocal` используется во вложенной функции для объявления того, что переменная относится к области видимости ближайшей внешней (но не глобальной) функции. Это позволяет вложенной функции изменять значение этой переменной из внешней функции. Правильный ответ — вариант 1.

# Вопрос 48. Тема 8: Сложность алгоритмов. Big O
  
Что означает сложность O(1)?
  
Варианты ответов:
1) Время равно n²
2) ❌ Время всегда растёт
3) Время не зависит от n
4) Время равно log n
5) Время равно n
  
### ИИ анализ
Студент выбрал неверный вариант. Обозначение O(1) описывает постоянную временную сложность. Это означает, что время выполнения алгоритма (или потребление памяти) не зависит от размера входных данных (n). Алгоритм выполняется за фиксированное, константное время. Правильный ответ — вариант 3.

# Вопрос 49. Тема 8: Сложность алгоритмов. Big O
  
Что означает сложность O(n)?
  
Варианты ответов:
1) Время растёт квадратно
2) Время зависит от памяти
3) ✅ Время растёт линейно
4) Время не меняется
5) Время растёт логарифмически
  
### ИИ анализ
Студент выбрал правильный ответ. Обозначение O(n) описывает линейную временную сложность. Время выполнения алгоритма растёт прямо пропорционально размеру входных данных (n). Если n удваивается, то и время выполнения в среднем удваивается. Это характерно для алгоритмов с одним циклом по входным данным.

# Вопрос 50. Тема 8: Сложность алгоритмов. Big O
  
Что означает сложность O(log n)?
  
Варианты ответов:
1) Время равно n²
2) Время не измеряют
3) ❌ Время равно n
4) Время всегда O(1)
5) Время растёт как log n
  
### ИИ анализ
Студент выбрал неверный вариант. Обозначение O(log n) описывает логарифмическую временную сложность. Время выполнения алгоритма растёт логарифмически относительно размера входных данных (n). Это очень эффективная сложность, характерная для алгоритмов, которые на каждом шаге делят задачу пополам, например, двоичный поиск. Правильный ответ — вариант 5.

# Вопрос 51. Тема 8: Сложность алгоритмов. Big O
  
Какая сложность обычно у двух вложенных циклов по `n` элементов?
  
Варианты ответов:
1) O(1)
2) O(n log n)
3) ❌ O(n)
4) O(n²)
5) O(log n)
  
### ИИ анализ
Студент выбрал неверный вариант. Если алгоритм содержит два вложенных цикла, каждый из которых выполняется примерно n раз, то общее количество итераций будет пропорционально n * n, то есть n². Это квадратичная временная сложность O(n²). Она характерна для многих простых алгоритмов сортировки и поиска пар. Правильный ответ — вариант 4.

# Вопрос 52. Тема 8: Сложность алгоритмов. Big O
  
Что означает «амортизированная сложность» на примере `list.append()`?
  
Варианты ответов:
1) Не измеряется
2) Всегда O(n²)
3) ❌ Всегда O(log n)
4) В среднем близко к O(1)
5) Всегда O(n)
  
### ИИ анализ
Студент выбрал неверный вариант. Амортизированная сложность рассматривает среднюю стоимость операции в худшем случае за последовательность вызовов. Для `list.append()` в Python, хотя иногда требуется дорогая операция перераспределения памяти (O(n)), её стоимость «распределяется» по многим быстрым добавлениям (O(1)), что в среднем даёт амортизированную сложность, близкую к O(1). Правильный ответ — вариант 4.

# Вопрос 53. Тема 8: Сложность алгоритмов. Big O
  
Что такое пространственно-временной компромисс (время vs память)?
  
Варианты ответов:
1) Меньше памяти без затрат
2) Выбор шрифта
3) ✅ Быстрее за счёт памяти
4) Нельзя менять память
5) Выбор версии Python
  
### ИИ анализ
Студент выбрал правильный ответ. Пространственно-временной компромисс — это классический принцип проектирования алгоритмов, согласно которому можно уменьшить время выполнения алгоритма, используя дополнительную память (например, кэширование, хеш-таблицы), или наоборот, уменьшить потребление памяти за счёт увеличения времени вычислений. Правильный ответ — вариант 3.

# Вопрос 54. Тема 8: Сложность алгоритмов. Big O
  
Какое общее изменение часто снижает сложность с O(n²) до O(n log n)?
  
Варианты ответов:
1) Использовать сортировку/разделение
2) Заменить if на elif
3) ❌ Убрать переменные
4) Добавить print
5) Использовать float
  
### ИИ анализ
Студент выбрал неверный вариант. Переход от сложности O(n²) к O(n log n) часто достигается за счёт применения стратегии «разделяй и властвуй» или использования эффективных структур данных. Например, замена алгоритма сортировки пузырьком (O(n²)) на быструю или сортировку слиянием (O(n log n)). Правильный ответ — вариант 1.

# Вопрос 55. Тема 9: Алгоритмы и структуры данных
  
Что такое стек (stack)?
  
Варианты ответов:
1) Граф
2) LIFO структура
3) ❌ FIFO структура
4) Дерево поиска
5) Хеш-таблица
  
### ИИ анализ
Студент выбрал неверный вариант. Стек — это абстрактный тип данных, который работает по принципу LIFO (Last In, First Out — «последним пришёл, первым ушёл»). Элементы добавляются (push) и извлекаются (pop) только с одного конца, называемого вершиной стека. Правильный ответ — вариант 2.

# Вопрос 56. Тема 9: Алгоритмы и структуры данных
  
Что такое очередь (queue)?
  
Варианты ответов:
1) Дерево
2) Словарь
3) ✅ FIFO структура
4) LIFO структура
5) Множество
  
### ИИ анализ
Студент выбрал правильный ответ. Очередь — это абстрактный тип данных, который работает по принципу FIFO (First In, First Out — «первым пришёл, первым ушёл»). Элементы добавляются (enqueue) в конец очереди и извлекаются (dequeue) из её начала. Это противоположно стеку.

# Вопрос 57. Тема 9: Алгоритмы и структуры данных
  
Какая сложность у двоичного поиска в отсортированном списке?
  
Варианты ответов:
1) O(log n)
2) O(1)
3) ❌ O(n²)
4) O(n log n)
5) O(n)
  
### ИИ анализ
Студент выбрал неверный вариант. Двоичный поиск работает за логарифмическое время O(log n). На каждом шаге алгоритм делит отсортированный интервал поиска пополам, что позволяет очень быстро находить элемент даже в больших массивах. Это намного эффективнее линейного поиска O(n). Правильный ответ — вариант 1.

# Вопрос 58. Тема 9: Алгоритмы и структуры данных
  
Какая средняя сложность у быстрой сортировки (quicksort)?
  
Варианты ответов:
1) O(1)
2) O(n log n)
3) ❌ O(n)
4) O(n²)
5) O(log n)
  
### ИИ анализ
Студент выбрал неверный вариант. В среднем случае быстрая сортировка (quicksort) имеет временную сложность O(n log n). Это достигается за счёт стратегии «разделяй и властвуй»: массив рекурсивно делится на части относительно опорного элемента. В худшем случае (плохой выбор опорного элемента) сложность может деградировать до O(n²). Правильный ответ — вариант 2.

# Вопрос 59. Тема 10: Работа с файлами
  
Что означает режим открытия файла `'r'`?
  
Варианты ответов:
1) Создание нового файла
2) Чтение существующего файла
3) ❌ Добавление в конец файла
4) Чтение и запись всегда
5) Запись с очисткой файла
  
### ИИ анализ
Студент выбрал неверный вариант. Режим `'r'` (от англ. read — чтение) предназначен для открытия существующего файла только для чтения. Если файл не существует, будет вызвано исключение `FileNotFoundError`. Это режим по умолчанию для функции `open()`. Правильный ответ — вариант 2.
# Вопрос 60. Тема 10: Работа с файлами
  
Что означает режим открытия файла `'r+'`?
  
Варианты ответов:
1) Только чтение
2) Только запись
3) ✅ Чтение и запись без очистки
4) Создание файла всегда
5) Добавление в конец
  
### ИИ анализ
Правильный ответ выбран верно. Режим `'r+'` позволяет и читать, и записывать данные в существующий файл, не удаляя его предыдущее содержимое при открытии. Это полезно для модификации файлов на месте. Важно помнить, что файл должен существовать, иначе будет вызвано исключение `FileNotFoundError`.  

# Вопрос 61. Тема 10: Работа с файлами
  
Как открыть файл так, чтобы он закрылся автоматически?
  
Варианты ответов:
1) Через `import open`
2) Через `def open_file():`
3) ❌ Через `print()`
4) Через `with open(...) as f:`
5) Через `input()`
  
### ИИ анализ
Выбран неверный вариант. Конструкция `with open(...) as f:` является контекстным менеджером, который гарантирует автоматическое закрытие файла после выхода из блока, даже если произошла ошибка. Это рекомендуемый способ работы с файлами в Python, предотвращающий утечки ресурсов.  

# Вопрос 62. Тема 10: Работа с файлами
  
Что такое контекстный менеджер при работе с файлами?
  
Варианты ответов:
1) Формат файла
2) Объект для `with` блока
3) ❌ Режим кодировки
4) Функция чтения
5) Вид переменной
  
### ИИ анализ
Выбран неверный вариант. Контекстный менеджер — это объект, который определяет методы `__enter__` и `__exit__` и используется с оператором `with`. При работе с файлами он обеспечивает корректное открытие и автоматическое закрытие файла, управляя ресурсами.  

# Вопрос 63. Тема 10: Работа с файлами
  
Как читать большой файл построчно, не загружая его целиком в память?
  
Варианты ответов:
1) `f.seek(0)`
2) `f.readlines()`
3) ✅ `for line in f:`
4) `f.write()`
5) `f.read()`
  
### ИИ анализ
Правильный ответ выбран верно. Итерация по файловому объекту с помощью `for line in f:` считывает файл построчно, что эффективно использует память. Методы `f.read()` и `f.readlines()` загружают весь файл сразу, что может быть проблематично для больших файлов.  

# Вопрос 64. Тема 10: Работа с файлами
  
Чем отличаются `read()`, `readline()`, `readlines()`?
  
Варианты ответов:
1) Разный объём чтения
2) Зависит от ОС
3) ❌ Они одинаковые
4) Только для бинарных
5) Только для JSON
  
### ИИ анализ
Выбран неверный вариант. Эти методы отличаются объемом и формой возвращаемых данных: `read()` читает весь файл в одну строку, `readline()` — одну строку, а `readlines()` — все строки в список. Понимание этих различий важно для выбора правильного метода под задачу.  

# Вопрос 65. Тема 10: Работа с файлами
  
Как проверить, что файл существует, до попытки чтения?
  
Варианты ответов:
1) `open.exists(path)`
2) `print(path)`
3) ✅ `Path(path).exists()`
4) `file.exists()`
5) `len(path) > 0`
  
### ИИ анализ
Правильный ответ выбран верно. Функция `Path(path).exists()` из модуля `pathlib` (или `os.path.exists`) позволяет проверить существование файла или директории. Это хорошая практика, чтобы избежать исключений при операциях с файлами, но нужно учитывать возможные состояния гонки.  

# Вопрос 66. Тема 10: Работа с файлами
  
Зачем указывать `encoding` при открытии текстового файла?
  
Варианты ответов:
1) Для запрета записи
2) Для сортировки строк
3) ❌ Для ускорения чтения
4) Для правильной кодировки текста
5) Для сжатия файла
  
### ИИ анализ
Выбран неверный вариант. Параметр `encoding` определяет кодировку символов в файле (например, `utf-8`). Его указание необходимо для корректного чтения и записи текста, особенно когда файл содержит не-ASCII символы, чтобы избежать ошибок `UnicodeDecodeError`.  

# Вопрос 67. Тема 11: ООП (урок 47)
  
Что такое класс в ООП?
  
Варианты ответов:
1) Конкретный объект
2) Имя функции
3) ❌ Файл с кодом
4) Шаблон для объектов
5) Тип цикла
  
### ИИ анализ
Выбран неверный вариант. Класс — это шаблон или чертёж, который определяет структуру и поведение будущих объектов (экземпляров). Он описывает атрибуты (данные) и методы (функции), которые будут у каждого созданного на его основе объекта.  

# Вопрос 68. Тема 11: ООП (урок 47)
  
Что такое объект (экземпляр класса)?
  
Варианты ответов:
1) Режим файла
2) Тип данных int
3) ❌ Описание класса
4) Созданный экземпляр класса
5) Модуль Python
  
### ИИ анализ
Выбран неверный вариант. Объект (экземпляр) — это конкретная реализация класса, созданная с использованием его шаблона. Каждый объект обладает своим собственным состоянием (значениями атрибутов), но разделяет поведение (методы), определённое в классе.  

# Вопрос 69. Тема 11: ООП (урок 47)
  
Для чего нужен метод `__init__`?
  
Варианты ответов:
1) Для удаления объекта
2) Для импорта модулей
3) ❌ Для печати объекта
4) Для сортировки списка
5) Для инициализации объекта
  
### ИИ анализ
Выбран неверный вариант. Метод `__init__` — это конструктор, который автоматически вызывается при создании нового экземпляра класса. Он используется для инициализации атрибутов объекта начальными значениями, которые часто передаются в качестве аргументов.  

# Вопрос 70. Тема 11: ООП (урок 47)
  
Что означает `self` в методах класса?
  
Варианты ответов:
1) Ссылка на список
2) Ссылка на файл
3) ❌ Ссылка на функцию
4) Ссылка на модуль
5) Ссылка на текущий объект
  
### ИИ анализ
Выбран неверный вариант. Параметр `self` — это ссылка на текущий экземпляр класса, через который метод получает доступ к атрибутам и другим методам этого конкретного объекта. Он явно передаётся как первый аргумент при определении метода, но не указывается при его вызове.  

# Вопрос 71. Тема 11: ООП (урок 47)
  
Что такое наследование?
  
Варианты ответов:
1) Скрытие данных
2) Сортировка массива
3) ❌ Перегрузка операторов
4) Чтение из файла
5) Получение свойств родителя
  
### ИИ анализ
Выбран неверный вариант. Наследование — это механизм, позволяющий дочернему классу (потомку) заимствовать атрибуты и методы родительского класса (предка). Это способствует повторному использованию кода и созданию иерархий классов.  

# Вопрос 72. Тема 11: ООП (урок 47)
  
Что такое инкапсуляция?
  
Варианты ответов:
1) Поиск в словаре
2) Повтор кода
3) ✅ Сокрытие деталей реализации
4) Быстрая сортировка
5) Чтение из stdin
  
### ИИ анализ
Правильный ответ выбран верно. Инкапсуляция — это принцип, объединяющий данные и методы, которые с ними работают, в одной единице (классе), и скрывающий внутренние детали реализации от внешнего использования. В Python это реализуется через соглашения об именовании (например, `_protected`).  

# Вопрос 73. Тема 11: ООП (урок 47)
  
Что такое полиморфизм?
  
Варианты ответов:
1) Разное поведение при одном интерфейсе
2) Только генераторы
3) ❌ Только инкапсуляция
4) Только множественное наследование
5) Один метод для одного класса
  
### ИИ анализ
Выбран неверный вариант. Полиморфизм позволяет объектам разных классов реагировать на один и тот же метод или операцию по-своему. Это означает, что один интерфейс может использоваться для объектов различного типа, повышая гибкость кода.  

# Вопрос 74. Тема 11: ООП (урок 47)
  
Для чего используют `super()`?
  
Варианты ответов:
1) Для чтения файла
2) Для выхода из функции
3) ✅ Для вызова метода родителя
4) Для поиска элемента
5) Для создания списка
  
### ИИ анализ
Правильный ответ выбран верно. Функция `super()` возвращает прокси-объект, который делегирует вызовы методов родительскому классу. Она часто используется в дочерних классах для расширения, а не полной замены методов родителя, например, в методе `__init__`.  

# Вопрос 75. Тема 11: ООП (урок 47)
  
Что такое множественное наследование?
  
Варианты ответов:
1) Наследование от нескольких классов
2) Наследование без init
3) ❌ Наследование только от object
4) Наследование без методов
5) Наследование только атрибутов
  
### ИИ анализ
Выбран неверный вариант. Множественное наследование — это возможность класса наследовать атрибуты и методы от более чем одного родительского класса. Это мощный инструмент, но он требует внимания к разрешению порядка наследования (MRO), чтобы избежать неоднозначностей.  

# Вопрос 76. Тема 11: ООП (урок 47)
  
Чем отличаются атрибуты класса и атрибуты экземпляра?
  
Варианты ответов:
1) Они всегда одинаковые
2) Экземпляр доступен только внутри класса
3) ❌ Атрибуты класса хранятся в списке
4) Класс общий, экземпляр свой
5) Атрибуты класса нельзя читать
  
### ИИ анализ
Выбран неверный вариант. Атрибуты класса являются общими для всех его экземпляров и определяются на уровне класса. Атрибуты экземпляра принадлежат конкретному объекту и обычно инициализируются в `__init__`. Если атрибут экземпляра не найден, Python ищет его в классе.
