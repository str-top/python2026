Вопросы с выбором варианта: 21/100%  
Вопросы с текстовыми ответами: 0/0%  
# Вопрос 1. Тема 1: Условные конструкции и циклы в Python
  
Какие значения в Python считаются ложными (falsy)?
  
Варианты ответов:
1) Значения, приводимые к False
2) Только None
3) Только отрицательные числа
4) Только пустые строки
5) ❌ Только значение 0
  
### ИИ анализ  
Выбранный вариант неверен. В Python к ложным (falsy) относятся не только 0, но и пустые коллекции (списки, строки, словари), `None`, и `False`.  Правильный ответ — это значения, которые при приведении к булевому типу дают `False`.  Для улучшения понимания стоит изучить стандартные falsy-значения в документации.

# Вопрос 2. Тема 1: Условные конструкции и циклы в Python
  
Зачем используется `elif`?
  
Варианты ответов:
1) Для обработки исключений
2) Для создания функции
3) Для вывода текста
4) ✅ Для добавления нового условия
5) Для остановки цикла
  
### ИИ анализ  
Ответ верный. Ключевое слово `elif` используется для добавления альтернативных условий в цепочку `if-else`.  Оно позволяет проверять несколько последовательных условий, выполняя только первый блок, условие которого истинно.  Это делает код чище и эффективнее, чем вложенные `if`.

# Вопрос 3. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `for`?
  
Варианты ответов:
1) Когда условие меняется случайно
2) Когда нужно повторять бесконечно
3) Когда нет итератора
4) ❌ Когда нужно ждать событие
5) Когда известен набор значений
  
### ИИ анализ  
Выбранный вариант неверен. Цикл `for` не предназначен для ожидания событий.  Цикл `for` удобнее использовать, когда известно количество итераций или есть итерируемый объект (список, строка, диапазон).  Для ожидания событий или циклов с неизвестным числом повторений больше подходит `while`.

# Вопрос 4. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `while`?
  
Варианты ответов:
1) ❌ Когда нужна сортировка
2) Когда есть range
3) Когда условие важно каждый раз
4) Когда нужен словарь
5) Когда есть список значений
  
### ИИ анализ  
Выбранный вариант неверен. Сортировка не связана с выбором типа цикла.  Цикл `while` удобнее использовать, когда количество итераций заранее неизвестно и выполнение зависит от условия, которое проверяется на каждой итерации.  Например, при чтении данных до появления определенного сигнала.

# Вопрос 5. Тема 1: Условные конструкции и циклы в Python
  
Что делает `break`?
  
Варианты ответов:
1) ❌ Останавливает программу
2) Перезапускает цикл
3) Пропускает итерацию
4) Полностью прерывает цикл
5) Переходит в else блока
  
### ИИ анализ  
Выбранный вариант неверен. Оператор `break` не останавливает всю программу, а только немедленно завершает выполнение самого внутреннего цикла, в котором он находится.  После `break` управление передается следующей за циклом инструкции.  Для пропуска итерации используется `continue`.

# Вопрос 6. Тема 1: Условные конструкции и циклы в Python
  
Что делает `continue`?
  
Варианты ответов:
1) ✅ Пропускает текущую итерацию
2) Возвращает значение
3) Завершает цикл полностью
4) Завершает программу
5) Переходит к else блока
  
### ИИ анализ  
Ответ верный. Оператор `continue` прерывает текущую итерацию цикла и сразу переходит к проверке условия следующей итерации (или к следующему элементу в цикле `for`).  Он полезен, когда нужно пропустить обработку некоторых элементов, не выходя из цикла полностью.

# Вопрос 7. Тема 1: Условные конструкции и циклы в Python
  
Когда выполняется `else` в конструкции `for ... else`?
  
Варианты ответов:
1) Только при ошибке
2) ❌ Только если был `continue`
3) Всегда после первого шага
4) Только если цикл пустой
5) Если цикл завершился без `break`
  
### ИИ анализ  
Выбранный вариант неверен. Блок `else` в цикле `for` выполняется не из-за `continue`, а только если цикл завершился естественным образом, то есть не был прерван оператором `break`.  Это полезно для поиска элементов: `else` сработает, если искомый элемент не был найден.

# Вопрос 8. Тема 1: Условные конструкции и циклы в Python
  
Как записать тернарное выражение (условие в одну строку) в Python?
  
Варианты ответов:
1) `if a: b else: c`
2) `if (a) {b} else {c}`
3) `b unless a else c`
4) ❌ `a ? b : c`
5) `b if a else c`
  
### ИИ анализ  
Выбранный вариант неверен. Синтаксис `a ? b : c` характерен для языков C/C++/Java, но не для Python.  Правильный синтаксис тернарного оператора в Python — `b if a else c`.  Он читается как "вернуть b, если условие a истинно, иначе вернуть c".

# Вопрос 9. Тема 1: Условные конструкции и циклы в Python
  
Что такое итерация в цикле `for`?
  
Варианты ответов:
1) Запуск программы
2) ✅ Один проход тела цикла
3) Создание списка
4) Объявление переменной
5) Завершение цикла
  
### ИИ анализ  
Ответ верный. Итерация — это однократное выполнение тела цикла для текущего элемента итерируемого объекта.  В цикле `for i in range(5)` будет выполнено 5 итераций.  Понимание этого термина важно для анализа сложности алгоритмов и логики работы циклов.

# Вопрос 10. Тема 1: Условные конструкции и циклы в Python
  
Как остановить цикл `while True` изнутри цикла?
  
Варианты ответов:
1) Использовать `elif`
2) Использовать `break`
3) ❌ Использовать `continue`
4) Использовать `pass`
5) Использовать `print`
  
### ИИ анализ  
Выбранный вариант неверен. Оператор `continue` не останавливает цикл, а только переходит к следующей итерации.  Для принудительного выхода из бесконечного цикла `while True` необходимо использовать оператор `break` при выполнении определенного условия внутри тела цикла.

# Вопрос 11. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.append(x)` от `list.extend(iterable)`?
  
Варианты ответов:
1) `append` добавляет один элемент
2) ❌ Разницы нет
3) `extend` удаляет элементы
4) `extend` добавляет один элемент
5) `append` добавляет все элементы
  
### ИИ анализ  
Выбранный вариант неверен. Разница есть и она принципиальна.  Метод `append(x)` добавляет один элемент `x` в конец списка, даже если `x` является списком (тогда он станет вложенным).  Метод `extend(iterable)` добавляет все элементы из итерируемого объекта по отдельности, расширяя список.

# Вопрос 12. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как обратиться к последнему элементу списка по индексу?
  
Варианты ответов:
1) `a[end]`
2) ❌ `a[0]`
3) `a[-1]`
4) `a[last]`
5) `a[1]`
  
### ИИ анализ  
Выбранный вариант неверен. `a[0]` обращается к первому элементу.  В Python для обращения к последнему элементу списка используется отрицательная индексация: `a[-1]`.  Это удобный синтаксис, где `-2` будет предпоследним элементом и так далее.

# Вопрос 13. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `start` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс конца среза
2) ❌ Количество элементов
3) Тип результата
4) Индекс начала среза
5) Шаг среза
  
### ИИ анализ  
Выбранный вариант неверен. Параметр `start` в срезе задает индекс элемента, с которого начинается срез (включая этот элемент).  Если `start` не указан, срез начинается с начала списка.  Количество элементов в результате зависит от разности `stop - start` с учетом шага.

# Вопрос 14. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `stop` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс конца, не включая
2) ❌ Индекс начала
3) Размер списка
4) Шаг
5) Значение элемента
  
### ИИ анализ  
Выбранный вариант неверен. Параметр `stop` задает индекс, на котором срез заканчивается, причем элемент с этим индексом **не включается** в результат.  Это важное правило, которое делает расчет длины среза простым: `stop - start`.  Если `stop` не указан, срез идет до конца списка.

# Вопрос 15. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `step` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс начала
2) ❌ Длину списка
3) Индекс конца
4) Шаг выборки элементов
5) Тип списка
  
### ИИ анализ  
Выбранный вариант неверен. Параметр `step` определяет шаг, с которым выбираются элементы из диапазона `[start:stop]`.  Например, `step=2` берет каждый второй элемент.  Отрицательный шаг позволяет идти в обратном порядке, что часто используется для реверса списка: `[::-1]`.

# Вопрос 16. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.copy()` от `list2 = list1`?
  
Варианты ответов:
1) Разницы нет
2) ❌ `copy()` связывает ссылки
3) `=` копирует элементы
4) `=` делает глубокую копию
5) `copy()` делает новый список
  
### ИИ анализ  
Выбранный вариант неверен. Присваивание `list2 = list1` не копирует список, а создает новую ссылку на тот же объект в памяти.  Метод `list.copy()` создает новый список (поверхностную копию), содержащий те же элементы.  Изменения в копии не затронут оригинал, и наоборот.

# Вопрос 17. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как правильно создать список списков без «общей» вложенной ссылки?
  
Варианты ответов:
1) `a = (0, 0, 0)`
2) ✅ `a = [[0] * 3 for _ in range(3)]`
3) `a = [0] * 9`
4) `a = [[0] * 3] * 3`
5) `a = {0: 3}`
  
### ИИ анализ  
Ответ верный. Конструкция `[[0] * 3 for _ in range(3)]` создает новый внутренний список на каждой итерации цикла, избегая проблемы общих ссылок.  Вариант `[[0] * 3] * 3` создает список, содержащий три ссылки на один и тот же внутренний список, что приводит к неожиданным изменениям.

# Вопрос 18. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что такое list comprehension?
  
Варианты ответов:
1) Тип словаря
2) ❌ Способ сортировки
3) Короткая запись создания списка
4) Способ чтения файла
5) Вид цикла while
  
### ИИ анализ  
Выбранный вариант неверен. List comprehension (генератор списка) — это компактный синтаксис для создания нового списка на основе итерируемого объекта, часто с применением фильтрации или преобразования.  Он не используется для сортировки, но может быть более читаемым и эффективным, чем обычный цикл `for`.

# Вопрос 19. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается удаление по индексу и удаление по значению в списке?
  
Варианты ответов:
1) По значению удаляют диапазон
2) По значению удаляют индекс
3) ❌ По индексу удаляют все совпадения
4) Разницы нет
5) По индексу удаляют позицию
  
### ИИ анализ  
Выбранный вариант неверен. Удаление по индексу (`list.pop(i)` или `del list[i]`) удаляет элемент в конкретной позиции.  Удаление по значению (`list.remove(x)`) удаляет **первый** элемент в списке, значение которого равно `x`.  Если совпадений несколько, остальные останутся в списке.

# Вопрос 20. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `sort()` от `sorted()`?
  
Варианты ответов:
1) Разницы нет
2) `sort()` возвращает новый список
3) ✅ `sort()` меняет список на месте
4) `sorted()` работает только с set
5) `sorted()` меняет список
  
### ИИ анализ  
Ответ верный. Метод `list.sort()` сортирует исходный список "на месте" (in-place) и возвращает `None`.  Встроенная функция `sorted(iterable)` возвращает новый отсортированный список, не изменяя исходную коллекцию.  `sorted()` работает с любым итерируемым объектом (списки, кортежи, строки).

# Вопрос 21. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `d.get(key)` от `d[key]`, если ключа нет?
  
Варианты ответов:
1) `get` удалит ключ
2) `get` всегда вызывает ошибку
3) ❌ `[]` вернёт None по умолчанию
4) Разницы нет
5) `get` вернёт None по умолчанию
  
### ИИ анализ  
Выбранный вариант неверен. Обращение `d[key]` к отсутствующему ключу вызовет исключение `KeyError`.  Метод `d.get(key)` в такой ситуации по умолчанию вернет `None` (или другое значение, указанное вторым аргументом).  Это делает `get()` безопасным для случаев, когда ключ может отсутствовать.

# Вопрос 22. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Как добавить или обновить значение в словаре по ключу?
  
Варианты ответов:
1) `d[key] = value`
2) `d.insert(key)`
3) ❌ `d.push(k, v)`
4) `d.add(k, v)`
5) `d.append(value)`
  
### ИИ анализ  
Выбранный вариант неверен. Методы `push`, `add` и `append` не существуют для словарей.  Для добавления новой пары ключ-значение или обновления существующего значения используется оператор присваивания: `d[key] = value`.  Если ключ уже есть, его значение будет перезаписано.

# Вопрос 23. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.keys()`?
  
Варианты ответов:
1) Количество ключей
2) Список ключей
3) ❌ Пару ключ-значение
4) Только первый ключ
5) Представление ключей (view)
  
### ИИ анализ  
Выбранный вариант неверен. В современных версиях Python (3.x) `dict.keys()` возвращает объект представления (view), который динамически отражает ключи словаря.  Это не список, но его можно легко преобразовать в список: `list(d.keys())`.  Представление эффективно использует память.

# Вопрос 24. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.values()`?
  
Варианты ответов:
1) Копию словаря
2) Список значений
3) ❌ Только уникальные значения
4) Ничего не возвращает
5) Представление значений (view)
  
### ИИ анализ  
Выбранный вариант неверен. Метод `dict.values()` возвращает объект представления (view) всех значений в словаре.  Значения в этом представлении не гарантированно уникальны.  Как и `keys()`, это динамическое отображение, изменения в словаре сразу видны в представлении.

# Вопрос 25. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.items()`?
  
Варианты ответов:
1) Только значения
2) Представление пар (key, value)
3) ❌ Сумму элементов
4) Только ключи
5) Индексы элементов
  
### ИИ анализ  
Выбранный вариант неверен. Метод `dict.items()` возвращает объект представления (view), содержащий кортежи вида `(ключ, значение)` для каждой пары в словаре.  Это очень полезно для итерации по словарю одновременно по ключам и значениям: `for k, v in d.items():`.

# Вопрос 26. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Когда удобно использовать `defaultdict`?
  
Варианты ответов:
1) Для удаления ключей
2) Для шифрования данных
3) ✅ Для значений по умолчанию
4) Для сортировки словаря
5) Для чтения файла
  
### ИИ анализ  
Ответ верный. `defaultdict` из модуля `collections` удобен, когда нужно автоматически создавать значения для отсутствующих ключей при первом обращении.  При создании `defaultdict` указывается фабричная функция (например, `list`, `int`), которая генерирует значение по умолчанию.

# Вопрос 27. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `set` от `frozenset`?
  
Варианты ответов:
1) `frozenset` поддерживает add
2) Разницы нет
3) ❌ `set` хранит пары
4) `set` всегда упорядочен
5) `frozenset` неизменяемый
  
### ИИ анализ  
Выбранный вариант неверен. Оба типа хранят уникальные элементы, а не пары.  Ключевое отличие: `set` — изменяемое множество (можно добавлять/удалять элементы), а `frozenset` — неизменяемое (хешируемое).  `frozenset` можно использовать как ключ словаря или элемент другого множества.

# Вопрос 28. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Какие операции множеств соответствуют: пересечение, объединение, разность?
  
Варианты ответов:
1) `in, not in, is`
2) `and, or, not`
3) ❌ `+, -, *`
4) `<<, >>, ^`
5) `&, |, -`
  
### ИИ анализ  
Выбранный вариант неверен. Для множеств в Python определены специальные операторы: пересечение (`&`), объединение (`|`), разность (`-`) и симметрическая разность (`^`).  Операторы `+` и `*` для множеств не работают.  Также доступны методы с теми же названиями.

# Вопрос 29. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит list comprehension с фильтром `if`?
  
Варианты ответов:
1) `[x for x in a if x > 0]`
2) `{x for x in a if x > 0}`
3) ❌ `(x for x in a if x > 0)`
4) `for x in a: if x > 0`
5) `{k: v for k, v in a}`
  
### ИИ анализ  
Выбранный вариант неверен. Вариант 3 — это выражение-генератор (generator expression), а не list comprehension.  Правильный синтаксис list comprehension с фильтром — квадратные скобки, внутри которых `for` и `if`: `[expression for item in iterable if condition]`.  Вариант 1 является верным примером.

# Вопрос 30. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит dict comprehension?
  
Варианты ответов:
1) `(k: v for k, v in pairs)`
2) `[k: v for k, v in pairs]`
3) ✅ `{k: v for k, v in pairs}`
4) `dict(k: v for k, v in pairs)`
5) `{k, v for k, v in pairs}`
  
### ИИ анализ  
Ответ верный. Dict comprehension (генератор словаря) использует фигурные скобки и синтаксис `ключ: значение` перед `for`: `{key_expr: value_expr for item in iterable}`.  Он создает новый словарь.  Вариант 1 — генераторное выражение с неверным синтаксисом, вариант 5 создал бы множество.

# Вопрос 31. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Как выглядит set comprehension?
  
Варианты ответов:
1) `{x for x in a}`
2) `(x for x in a)`
3) ❌ `[x for x in a]`
4) `set[x for x in a]`
5) `{k: v for k, v in a}`
  
### ИИ анализ  
Выбранный вариант неверен. Вариант 3 — это list comprehension, создающий список.  Set comprehension (генератор множества) использует фигурные скобки, как и dict comprehension, но без двоеточия: `{expression for item in iterable}`.  Вариант 1 является верным примером создания множества.

# Вопрос 32. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Чем отличается `if/else` внутри comprehension от фильтра `if` в конце?
  
Варианты ответов:
1) Они делают одно и то же
2) `if/else` удаляет элементы
3) ❌ Фильтр `if` создаёт else
4) Фильтр `if` всегда медленней
5) `if/else` меняет значение
  
### ИИ анализ  
Выбранный вариант неверен. Условное выражение (`x if condition else y`) **перед** `for` определяет, какое значение будет включено в результат для каждого элемента.  Фильтр `if` **после** `for` решает, будет ли элемент вообще включен в результат.  Они служат разным целям.

# Вопрос 33. Тема 4: Генераторы коллекций. list, dict, set comprehensions
  
Когда comprehension лучше заменить обычным циклом `for`?
  
Варианты ответов:
1) Когда нужен `range`
2) Когда есть словарь
3) ✅ Когда логика стала сложной
4) Когда нужен `if`
5) Когда список маленький
  
### ИИ анализ  
Ответ верный. Comprehension предназначены для простых и понятных преобразований.  Если логика внутри становится сложной (например, много вложенных условий, обработка исключений, побочные эффекты), обычный цикл `for` будет читаемее и проще для отладки.  Ясность кода важнее краткости.

# Вопрос 34. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что такое позиционный аргумент при вызове функции?
  
Варианты ответов:
1) Аргумент из файла
2) ❌ Аргумент только в списке
3) Аргумент из словаря
4) Аргумент по порядку параметров
5) Аргумент с именем
  
### ИИ анализ  
Выбранный вариант неверен. Позиционный аргумент — это аргумент, который передается функции в том порядке, в котором определены параметры.  Его значение связывается с соответствующим параметром на основе позиции, а не имени.  Например, в вызове `func(a, b)` оба аргумента позиционные.

# Вопрос 35. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что такое именованный аргумент при вызове функции?
  
Варианты ответов:
1) Аргумент с типом str
2) ❌ Аргумент только в списке
3) Аргумент с индексом
4) Аргумент без значения
5) Аргумент вида `name=value`
  
### ИИ анализ  
Выбранный вариант неверен. Именованный (или ключевой) аргумент передается с явным указанием имени параметра в формате `имя_параметра=значение`.  Это позволяет передавать аргументы в любом порядке и часто используется для параметров со значениями по умолчанию, чтобы улучшить читаемость кода.

# Вопрос 36. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Почему опасно использовать изменяемый объект (например, `[]`) как значение по умолчанию?
  
Варианты ответов:
1) Он медленно создаётся
2) ❌ Он запрещён в Python
3) Он ломает import
4) Он сохраняется между вызовами
5) Он всегда пустой
  
### ИИ анализ  
Выбранный вариант неверен. Использование изменяемого объекта по умолчанию не запрещено, но это частая ошибка.  Значение по умолчанию вычисляется один раз при определении функции.  Если это один и тот же изменяемый объект (например, список), его изменения будут сохраняться между вызовами, что приводит к неожиданному поведению.

# Вопрос 37. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Для чего используется `*args`?
  
Варианты ответов:
1) Для возврата значения
2) ❌ Для передачи словаря
3) Для набора позиционных аргументов
4) Для остановки цикла
5) Для создания класса
  
### ИИ анализ  
Выбранный вариант неверен. Параметр `*args` в определении функции используется для сбора произвольного количества **позиционных** аргументов в кортеж.  Это позволяет создавать функции с переменным числом аргументов.  Для передачи словаря именованных аргументов используется `**kwargs`.

# Вопрос 38. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Для чего используется `**kwargs`?
  
Варианты ответов:
1) Для набора списков
2) ❌ Для форматирования строки
3) Для чтения файла
4) Для набора именованных аргументов
5) Для создания модуля
  
### ИИ анализ  
Выбранный вариант неверен. Параметр `**kwargs` в определении функции используется для сбора произвольного количества **именованных** аргументов (которые не соответствуют явно объявленным параметрам) в словарь.  Это полезно для создания гибких API или функций-оберток.

# Вопрос 39. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что означает `return` в функции?
  
Варианты ответов:
1) Объявление переменной
2) ❌ Печать результата
3) Импорт модуля
4) Повтор вызова
5) Возврат значения и выход
  
### ИИ анализ  
Выбранный вариант неверен. Оператор `return` завершает выполнение функции и возвращает указанное значение в точку вызова.  Он не выводит значение на экран (для этого используется `print()`).  Функция может содержать несколько `return` или не содержать его вовсе (тогда она возвращает `None`).

# Вопрос 40. Тема 5: Функции. параметры, значения по умолчанию, args, kwargs, область видимости
  
Что возвращает функция, если в ней нет `return`?
  
Варианты ответов:
1) None
2) ❌ False
3) Ошибку
4) 0
5) Пустую строку
  
### ИИ анализ  
Выбранный вариант неверен. В Python функция, которая не содержит оператора `return` или содержит `return` без значения, автоматически возвращает специальный объект `None`.  `None` — это единственный объект типа `NoneType`, обозначающий отсутствие значения.  Это не то же самое, что `False`, `0` или пустая строка.

# Вопрос 41. Тема 7: Функции args, kwargs, область видимости
  
В каком порядке обычно пишут параметры, если используются `*args` и `**kwargs`?
  
Варианты ответов:
1) Только `*args`, без обычных
2) Сначала `*args`, потом обычные
3) ❌ Порядок не важен
4) `**kwargs`, потом `*args`
5) Обычные, потом `*args`, потом `**kwargs`
  
### ИИ анализ  
Выбранный вариант неверен. Порядок строго определен синтаксисом Python.  Сначала идут обычные позиционные параметры, затем параметры со значениями по умолчанию (или `*`), затем `*args` для сбора лишних позиционных аргументов, и в самом конце `**kwargs` для сбора лишних именованных аргументов.

# Вопрос 42. Тема 7: Функции args, kwargs, область видимости
  
Что произойдёт, если передать позиционный аргумент после именованного?
  
Варианты ответов:
1) Будет предупреждение
2) Python это игнорирует
3) ❌ Код отработает нормально
4) Позиционный станет ключевым
5) Будет ошибка синтаксиса
  
### ИИ анализ  
Выбранный вариант неверен. При вызове функции все позиционные аргументы должны идти **перед** любыми именованными аргументами.  Если передать позиционный аргумент после именованного, Python выдаст синтаксическую ошибку.  Это правило необходимо для однозначного сопоставления аргументов с параметрами.

# Вопрос 43. Тема 7: Функции args, kwargs, область видимости
  
Как передать `*args` и `**kwargs` в другую функцию?
  
Варианты ответов:
1) Использовать `f(*kwargs, **args)`
2) Использовать `f(&args, &kwargs)`
3) ✅ Использовать `f(*args, **kwargs)`
4) Передать как строки
5) Использовать `f(args, kwargs)`
  
### ИИ анализ  
Ответ верный. Для передачи собранных аргументов в другую функцию используется распаковка: `*args` распаковывает кортеж позиционных аргументов, `**kwargs` распаковывает словарь именованных аргументов.  Это мощный прием для создания функций-декораторов или оберток.

# Вопрос 44. Тема 7: Функции args, kwargs, область видимости
  
Что такое локальная область видимости?
  
Варианты ответов:
1) Переменные в классе всегда
2) Переменные в библиотеке
3) ❌ Переменные в файле
4) Переменные внутри функции
5) Переменные из модуля
  
### ИИ анализ  
Выбранный вариант неверен. Локальная область видимости (local scope) — это область внутри тела функции.  Переменные, определенные внутри функции (включая параметры), являются локальными и не видны за ее пределами.  Переменные в файле (на