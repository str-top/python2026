Результат теста: 0/40%  
Обновленный результат: 90/100%  
# ❌ Вопрос 1. Временная сложность операций
  
## Временная сложность операций

Какова временная сложность поиска элемента в следующих структурах данных?

```python
# 1. Поиск в списке (list)
my_list = [1, 2, 3, 4, 5]
x = 3 in my_list

# 2. Поиск в множестве (set)
my_set = {1, 2, 3, 4, 5}
x = 3 in my_set

# 3. Поиск по ключу в словаре (dict)
my_dict = {'a': 1, 'b': 2, 'c': 3}
x = my_dict['b']
```
  
Варианты ответов:
- [ ] Option 1: O(n), O(1), O(1) - линейный для списка, константный для set и dict
- [ ] Option 2: O(1), O(1), O(1) - все операции константные
- [X] **Option 3: O(n), O(n), O(n) - все операции линейные**
- [ ] Option 4: O(log n), O(log n), O(log n) - все логарифмические
- [ ] Option 5: O(n), O(log n), O(1) - линейный, логарифмический, константный
  
## ИИ анализ
Неправильный выбор. Для списка поиск действительно O(n), но для set и dict поиск по ключу выполняется за O(1) благодаря хеш-таблицам. Правильный ответ - Option 1. Студент ошибочно считает все операции линейными.
  
#  Вопрос 2. Пространственная сложность
  
## Пространственная сложность

Проанализируйте пространственную сложность следующего рекурсивного алгоритма вычисления факториала:

```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

Объясните, сколько памяти используется в стеке вызовов и как это зависит от n.
  
Answer:
asdfasdfad
  
## ИИ анализ
Ответ не содержит полезной информации. Пространственная сложность O(n) из-за глубины рекурсии: при вызове factorial(n) в стеке одновременно хранится n фреймов вызовов. Каждый рекурсивный вызов добавляет новый фрейм в стек.