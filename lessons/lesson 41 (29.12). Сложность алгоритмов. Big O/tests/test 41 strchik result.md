## Результат теста: 2/2%
# ✅ Вопрос 1. ## Временная сложность операций

Какова временная сложность поиска элемента в следующих структурах данных?

```python
# 1. Поиск в списке (list)
my_list = [1, 2, 3, 4, 5]
x = 3 in my_list

# 2. Поиск в множестве (set)
my_set = {1, 2, 3, 4, 5}
x = 3 in my_set

# 3. Поиск по ключу в словаре (dict)
my_dict = {'a': 1, 'b': 2, 'c': 3}
x = my_dict['b']
```
  
Answer options:
- [ ] Option 1: O(n), O(1), O(1) - линейный для списка, константный для set и dict
- **[X] Option 2:** O(1), O(1), O(1) - все операции константные
- [ ] Option 3: O(n), O(n), O(n) - все операции линейные
- [ ] Option 4: O(log n), O(log n), O(log n) - все логарифмические
- [ ] Option 5: O(n), O(log n), O(1) - линейный, логарифмический, константный
  
## ИИ анализ
  
#  Вопрос 2. ## Пространственная сложность

Проанализируйте пространственную сложность следующего рекурсивного алгоритма вычисления факториала:

```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

Объясните, сколько памяти используется в стеке вызовов и как это зависит от n.
  
Answer:
kgjh
  
## ИИ анализ
  
#  Вопрос 3. ## Практический анализ

Имеется функция для проверки, является ли строка палиндромом:

```python
def is_palindrome(s):
    # Удаляем все не-буквенные символы и приводим к нижнему регистру
    cleaned = ''.join(c.lower() for c in s if c.isalnum())
    # Сравниваем с обратной строкой
    return cleaned == cleaned[::-1]
```

Проанализируйте:
1. Временную сложность по времени
2. Пространственную сложность
3. Можно ли оптимизировать этот алгоритм по памяти?
4. Предложите оптимизированную версию
  
Answer:
qwersdf
  
## ИИ анализ
  
# ✅ Вопрос 4. ## Оптимизация циклов

Дан код для поиска двух чисел с суммой target:

```python
def find_two_sum(arr, target):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == target:
                return [arr[i], arr[j]]
    return None
```

Какова временная сложность и как её можно улучшить?
  
Answer options:
- [ ] Option 1: O(n²) - можно улучшить до O(n) используя set для хранения нужных чисел
- [ ] Option 2: O(n) - уже оптимальное решение
- **[X] Option 3:** O(n·log n) - можно улучшить до O(n) с сортировкой
- [ ] Option 4: O(2ⁿ) - можно улучшить до O(n²) с динамическим программированием
- [ ] Option 5: O(n³) - можно улучшить до O(n²) убрав внутренний цикл
  
## ИИ анализ
  
#  Вопрос 5. ## Анализ временной сложности

Проанализируйте временную сложность следующего алгоритма:

```python
def find_duplicates(arr):
    seen = set()
    duplicates = set()
    for item in arr:
        if item in seen:
            duplicates.add(item)
        else:
            seen.add(item)
    return list(duplicates)
```

Объясните по шагам, почему сложность именно такая, и предложите оптимизацию, если это возможно.
  
Answer:
qwersdf
  
## ИИ анализ
